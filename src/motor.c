/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

#include "motor.h"
#include <msp430.h>
#include <driverlib.h>
#include <stdlib.h>
#include <ucs.h>

#include "descriptors.h"
#include "usbApp/usbConstructs.h"

#define PERIOD 0xff
#define STEPS 128
//#define CLK_FREQ 10000000
#define MICROSTEP_MIN_DELAY 128

/**
 * Anything between 0 to 511.
 */
static volatile uint16_t currentRelativeMicrostep = 0;
static volatile uint16_t currentAbsoluteMicrostep = 0;
static volatile uint16_t setAbsoluteMicrostep = 0;

/**
 * Sine table generated by the python script included in this source code (build directory). Sine and the latter consine
 * tables are used for generating proper voltges (PWMs actually) for motor windings.
 */
#include "functions.h"

/**
 * From 0 to PERIOD (including).
 */
void setWinding1 (int power)
{
        TA0CCR1 = PERIOD - abs (power);

        if (power >= 0) {
                P1OUT &= ~GPIO_PIN0;
        }
        else {
                P1OUT |= GPIO_PIN0;
        }
}

void setWinding2 (int power)
{
        TA0CCR2 = PERIOD - abs (power);

        if (power >= 0) {
                P1OUT &= ~GPIO_PIN1;
        }
        else {
                P1OUT |= GPIO_PIN1;
        }
}

/**
 * Initialize timer as PWM generator.
 */
void initPWM (void)
{
        GPIO_setAsPeripheralModuleFunctionOutputPin (GPIO_PORT_P1, GPIO_PIN2 | GPIO_PIN3);
//        GPIO_setAsOutputPin (GPIO_PORT_P6, GPIO_PIN0 | GPIO_PIN1 | GPIO_PIN2 | GPIO_PIN3);
        GPIO_setAsOutputPin (GPIO_PORT_P1, GPIO_PIN0 | GPIO_PIN1);

        /*
         * Konfiguracja pierwszego timera typu A. Wybór źródła sygnału zegarowego za pomocą :
         * TASSEL_0 : TAxCLK sygnał zewnętrzny. ?
         * TASSEL_1 : ACLK sygnał wewnętrzny. Auxiliary clock.
         * TASSEL_2 : SMCLK sygnał wewnętrzny. Subsystem master clock.
         * TASSEL_3 : INCLK sygnał zewnętrzny. ?
         *
         */
        TA0CTL |= TASSEL_2 |

        /*
         * Pierwszy divider. Możliwe opcje to:
         * ID_0 : /1
         * ID_1 : /2
         * ID_2 : /4
         * ID_3 : /8
         */
        ID_0 |

        /*
         * Tryb działania
         * Timer mode control: 0 - Stop
         *
         * Timer mode control: 1 - Up to TAxCCR0 i znów od 0. W tym przypadku używany jest tylko TAxCCR0 (Timer_Ax Capture/Compare 0).
         *                         Kiedy timer dojdzie do wartości TAxCCR0, to ustawiany jest bit CCIFG w rejestrze TAxCCTL0. Natomiast
         *                         zaraz potem, kiedy  tylko timer się wyzeruje µC ustawia bit TAIFG w rejestrze TAxCTL (Timer_Ax Control).
         *                         Czyli te zdarzenia następują zaraz po sobie.
         *
         * Timer mode control: 2 - Continuous up, czyli liczy do 0xffff i znów od zera. Kiedy dojdzie do 0xffff, to ustawia TAIFG w TAxCTL
         *                         (Timer_Ax Control), tak samo jak w poprzednim wypadku.
         *
         * Timer mode control: 3 - Up/Down, cyzli od 0 do TAxCCR0 i potem do 0 i w kółko.
         *
         */
        MC_1;

        /*
         * Dalszy podział sygnału zegarowego. Możliwe wartości:
         * TAIDEX_0 : /1
         * TAIDEX_1 : /2
         * TAIDEX_2 : /3
         * TAIDEX_3 : /4
         * TAIDEX_4 : /5
         * TAIDEX_5 : /6
         * TAIDEX_6 : /7
         * TAIDEX_7 : /8
         */
        TA0EX0 = TAIDEX_0;

        // Można ustawić aktualny stan timera, ale nie trzeba.
        TA0R = 0;

        /*
         * Reset timera. Zawsze wykonać po ustawieniu dzielników sygnału zegarowego.
         */
        TA0CTL |= TACLR;


/*---------------------------------------------------------------------------*/

        TA0CCR0 = PERIOD;

        TA0CCR1 = (PERIOD / 2);
        TA0CCTL1 |= OUTMOD_3; // Toggle


        TA0CCR2 = (PERIOD / 2);
        TA0CCTL2 |= OUTMOD_3; // Toggle
}

void initTimerA1 (void)
{
        /*
         * Konfiguracja pierwszego timera typu A. Wybór źródła sygnału zegarowego za pomocą :
         * TASSEL_0 : TAxCLK sygnał zewnętrzny. ?
         * TASSEL_1 : ACLK sygnał wewnętrzny. Auxiliary clock.
         * TASSEL_2 : SMCLK sygnał wewnętrzny. Subsystem master clock.
         * TASSEL_3 : INCLK sygnał zewnętrzny. ?
         *
         */
        TA1CTL |= TASSEL_1 |

        /*
         * Pierwszy divider. Możliwe opcje to:
         * ID_0 : /1
         * ID_1 : /2
         * ID_2 : /4
         * ID_3 : /8
         */
        ID_0 |

        /*
         * Tryb działania
         * Timer mode control: 0 - Stop
         *
         * Timer mode control: 1 - Up to TAxCCR0 i znów od 0. W tym przypadku używany jest tylko TAxCCR0 (Timer_Ax Capture/Compare 0).
         *                         Kiedy timer dojdzie do wartości TAxCCR0, to ustawiany jest bit CCIFG w rejestrze TAxCCTL0. Natomiast
         *                         zaraz potem, kiedy  tylko timer się wyzeruje µC ustawia bit TAIFG w rejestrze TAxCTL (Timer_Ax Control).
         *                         Czyli te zdarzenia następują zaraz po sobie.
         *
         * Timer mode control: 2 - Continuous up, czyli liczy do 0xffff i znów od zera. Kiedy dojdzie do 0xffff, to ustawia TAIFG w TAxCTL
         *                         (Timer_Ax Control), tak samo jak w poprzednim wypadku.
         *
         * Timer mode control: 3 - Up/Down, cyzli od 0 do TAxCCR0 i potem do 0 i w kółko.
         *
         */
        MC_1 |
        TAIE; // Włącz przerwanie

        /*
         * Dalszy podział sygnału zegarowego. Możliwe wartości:
         * TAIDEX_0 : /1
         * TAIDEX_1 : /2
         * TAIDEX_2 : /3
         * TAIDEX_3 : /4
         * TAIDEX_4 : /5
         * TAIDEX_5 : /6
         * TAIDEX_6 : /7
         * TAIDEX_7 : /8
         */
        TA1EX0 = TAIDEX_0;

        // Można ustawić aktualny stan timera, ale nie trzeba.
        TA1R = 0;

        /*
         * Reset timera. Zawsze wykonać po ustawieniu dzielników sygnału zegarowego.
         */
        TA1CTL |= TACLR;


/*---------------------------------------------------------------------------*/

        TA1CCR0 = 0xf;

        TA1CCR1 = (0xf - 1);
        TA1CCTL1 = OUTMOD_0 | CCIE;
}


__attribute__((interrupt(TIMER1_A1_VECTOR)))
void timeIterrupt22(void)
{
        int16_t diff = setAbsoluteMicrostep - currentAbsoluteMicrostep;

        if (diff > 0) {
                moveRightRelative ();
        }
        else if (diff < 0) {
                moveLeftRelative ();
        }
        // else : we are on set position, no movement here.

        TA1CTL &= ~TAIFG;
        TA1CCTL1 &= ~CCIFG;
}


void moveRightRelative ()
{
        ++currentRelativeMicrostep;

        if (currentRelativeMicrostep >= STEPS) {
                currentRelativeMicrostep = 0;
        }

        setWinding1 (COSINE[currentRelativeMicrostep]);
        setWinding2 (SINE[currentRelativeMicrostep]);

        if (currentAbsoluteMicrostep < STEPS * 5) {
                ++currentAbsoluteMicrostep;
        }
}


/**
 * We have STEPS * 20 / 4 steps fullscale. TODO consider ramping up. If it is necessary, or not and what ease function to use (cosine? linear?)
 * Caution this function invalidates the absolute position variable, so moveAbsolute won't work properly after call to either moveRightRelative
 * or moveLeftRelative.
 */
//void moveRightRelative (uint16_t microSteps)
//{
//        while (microSteps) {
//                ++currentRelativeMicrostep;
//
//                if (currentRelativeMicrostep >= STEPS) {
//                        currentRelativeMicrostep = 0;
//                }
//
//                setWinding1 (COSINE[currentRelativeMicrostep]);
//                setWinding2 (SINE[currentRelativeMicrostep]);
//
//                --microSteps;
//        }
//}

/**
 * \see moveRightRelative
 */
//void moveLeftRelative (uint16_t microSteps)
//{
//        while (microSteps) {
//                --currentRelativeMicrostep;
//
//                if (currentRelativeMicrostep == 0) {
//                        currentRelativeMicrostep = STEPS - 1;
//                }
//
//                setWinding1 (COSINE[currentRelativeMicrostep]);
//                setWinding2 (SINE[currentRelativeMicrostep]);
//
//                --microSteps;
//        }
//}

/**
 * \see moveRightRelative
 */
void moveLeftRelative ()
{
        --currentRelativeMicrostep;

        if (currentRelativeMicrostep == 0) {
                currentRelativeMicrostep = STEPS - 1;
        }

        setWinding1 (COSINE[currentRelativeMicrostep]);
        setWinding2 (SINE[currentRelativeMicrostep]);

        if (currentAbsoluteMicrostep > 0) {
                --currentAbsoluteMicrostep;
        }
}

///**
// *
// */
//void moveAbsolute (uint16_t microSteps)
//{
//        currentAbsoluteMicrostep = microSteps - currentAbsoluteMicrostep;
//
//        if (currentAbsoluteMicrostep > 0) {
//                moveRightRelative (currentAbsoluteMicrostep);
//        }
//        else {
//                moveLeftRelative (currentAbsoluteMicrostep);
//        }
//}

/**
 * TODO STEPS-> microSTEPS, 5 -> teethNo
 * Anything between 0 and STEPS * 5 (steps * teets)
 */
void moveAbsolute (uint16_t microSteps)
{
        setAbsoluteMicrostep = microSteps;
}

//void rotate (void)
//{
//
//        while (1) {
//                setWinding1 (COSINE[0]);
//                setWinding2 (SINE[0]);
//
//                // Delay
//                for (uint16_t i = 0; i < 0xf; ++i)
//                        for (uint16_t j = 0; j < 0xffff; ++j)
//                                asm ("nop");
//
//                for (int k = 0; k < 5 * 3; ++k) {
//
//                        for (int j = 0; j < STEPS; ++j) {
//
//                                setWinding1 (COSINE[j]);
//                                setWinding2 (SINE[j]);
//
//                                // Delay
//                                for (int i = 0; i < 4*1024; ++i)
//                                        ;
//                        }
//                }
//        }
//}
